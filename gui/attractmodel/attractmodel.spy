Type Data_ATTRACT_Structures:Data{}
Type Data_ATTRACT_Rotations:Data{}
Type Data_ATTRACT_Translations:Data{}
Type Data_ATTRACT_Modes:Data{}
Type Data_ATTRACT_CryoEM:Data{}

Type Data_TXT_FileList_PDB:Data{}

Type AttractSymmetry {
  *Coordinate symmetry_axis
  *Coordinate symmetry_origin
  form {
    symmetry_axis.add_header("You can use generative symmetry or distance-restrained symmetry")
    symmetry_axis.add_header("If you want to use generative symmetry:")
    symmetry_axis.add_header(" - Provide an explicit symmetry axis and origin")    
    symmetry_axis.add_header(" - Specify a single reference symmetry partner")
    symmetry_axis.add_header(" - In the Docking Partner section, only define the reference partner structure")    
    symmetry_axis.add_header("If you want to use distance-restrained symmetry:")
    symmetry_axis.add_header(" - Do not provide explicit symmetry axis and origin")    
    symmetry_axis.add_header(" - Specify all symmetry partners that are to be restrained")    
    symmetry_axis.add_header(" - In the Docking Partner section, specify all partner structures, which must be identical")
    symmetry_axis.name = "Generative symmetry axis"
    symmetry_origin.name = "Origin for generative symmetry axis"
  }
  Enum symmetry("Cx","Dx") = "Cx"
  validate {
    if symmetry_origin is not None: assert symmetry_axis is not None
  }
  IntegerArray partners = []
  form {
    partners.form = "soft"
  }  
  validate {
    if symmetry_axis is not None: assert len(partners) == 1
    else:
      assert len(partners) > 1
      if symmetry == "Dx": assert len(partners) == 4
  }
}


Type AttractPartnerInterface {
  ## form pdbfile.type = "file"
  ## form pdbfile.name = "Structure file"
  *ResourceData_PDB pdbfile
  
  ## form code.length = 4  
  ## form code.name = "Or define?"
  *PDBCode code

  *String gridname
  ## form gridname.name = "Name of the grid to use for this molecule"
  
  ## form chain.name = "Which chain of the structure must be used?"
  ## form chain.options = "All", "A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"
  String chain = "All"
        
  #RestraintsInterface r = RestraintsInterface()
  ## #form r.name = "Restraint definition"
      
  Bool is_reduced = False
  ## form is_reduced.name = "The molecule is already in reduced form"

  Enum moleculetype("Protein", "DNA", "RNA") = "Protein"
  ## form moleculetype.name = "What kind of molecule are you docking?"
  ## form moleculetype.optiontitles = "Protein/peptide", "DNA", "RNA"
  
  Bool generate_modes = False
  ## form generate_modes.name = "Generate harmonic modes"
  
  *ResourceData_ATTRACT_Modes modes_file 
  ## form modes_file.name = "Harmonic modes file"
  ## form modes_file.type = "file"
  *ResourceData_ATTRACT_Modes aa_modes_file 
  ## form aa_modes_file.name = "All-atom harmonic modes file (for RMSD/collect)"
  ## form aa_modes_file.type = "file"
  *Integer nr_modes = 0
  form {
    nr_modes.name = "Number of harmonic modes to select"
    nr_modes.type = "option"
    nr_modes.options = list(range(0,10+1))
    nr_modes.optiontitles = ["No modes"] + [str(v) for v in nr_modes.options[1:]]
  }
  ## validate if generate_modes: assert nr_modes is not None
  ## validate if generate_modes: assert modes_file is None
  ## validate if nr_modes not in (None, 0): assert nr_modes >= 1 and nr_modes <= 10
    
  Bool ensemble = False
  *ResourceData_TXT_FileList_PDB ensemble_list
  ## form ensemble_list.name = "Ensemble list file"
  ## form ensemble_list.type = "file"
  *Integer ensemble_size
  ## form ensemble_size.name = "Number of conformers in the ensemble"
  ## validate assert ensemble_size is None or ensemble_size > 0
  *Enum ensemblize("random","all","custom")
  ## form ensemblize.name = "Ensemble search"
  ## form ensemblize.optiontitles = "Random", "All", "Custom (none)"
  
  Bool auto_his = True  
  #HistidineStateArray his = []
  Bool charged_nter = True
  Bool charged_cter = True
  
  Bool deflex = False
  ## form deflex.add_header("If you perform RMSD analysis, you may remove all flexibility (ensemble and modes) beforehand")
  ## form deflex.name = "Remove flexibility" 

  *ResourceData_PDB rmsd_pdb
  ## form rmsd_pdb.add_header("You can specify a PDB file to use as reference in RMSD calculations")
  ## form rmsd_pdb.add_header("Leave blank to use the docked PDB instead (bound conformation = unbound conformation)")
  ## form rmsd_pdb.name = "RMSD PDB file"
  ## form rmsd_pdb.type = "file"
  Bool rmsd_bb = True
  ## form rmsd_bb.name = "Select only backbone atoms for RMSD calculation"

  *ResourceData_PDB collect_pdb
  ## form collect_pdb.add_header("You can specify a different PDB file to use as template for collecting the structures")
  ## form collect_pdb.add_header("Leave blank to use the reduced PDB instead")
  ## form collect_pdb.name = "Collect PDB file"
  ## form collect_pdb.type = "file"
  *ResourceData_TXT_FileList_PDB collect_ensemble_list
  ## form collect_ensemble_list.add_header("If you specified a PDB file above, you may provide an ensemble conformer list for it")
  ## form collect_ensemble_list.name = "Collect ensemble list file"
  ## form collect_ensemble_list.type = "file"

  form {
    """
    For now, disable advanced features
    """
    #r.type = None
    moleculetype.type = None
    auto_his.type = None
    #his.type = None
    #his.length = 10
    charged_nter.type = None
    charged_cter.type = None
  }  
  validate {
    if (pdbfile is None and code is None):
       raise spyder.core.ValidationError("Please upload a PDB file or provide a PDB code")
    if (pdbfile is not None and code is not None):
       raise spyder.core.ValidationError("Please upload a PDB file or provide a PDB code, not both")
    if chain not in ("All", "A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"):
       raise spyder.core.ValidationError("Please provide a chain")  
    assert (ensemble_size is None) == (ensemble_list is None) == (ensemblize == None)
    assert is_reduced == False or code is None
  }
}

Type AttractGrid:Degenerate {
  String gridname = ""
  ## form gridname.name = "Name of this grid"
  validate {
    gridname = gridname.strip()
    assert len(gridname) > 0
    self.gridname = gridname
    if not gridname.replace("_","").replace("-","").isalnum():
      raise ValueError("The name of the grid may contain only letters, digits, _ and -")  
  }

  *Filename gridfile
  form {
    gridfile.type = "file"
    gridfile.file = "Data"
    gridfile.add_header("If a grid file has been previously generated, you can specify it here")
    gridfile.name = "Grid file"
  }
  ## form omp.add_header("Do you want to calculate the grid on multiple cores using OpenMP?")
  Bool omp = False
  ## form torque.add_header("Is the grid a torque grid?")
  Bool torque = False
  Bool mask_interior = False
  ## form mask_interior.name = "Mask the protein interior before grid calculation"
  Float plateau_distance = 10.0
  ## form plateau_distance.name = "Plateau distance (A) for grid calculation"
  Float neighbour_distance = 12.0 
  ## form neighbour_distance.name = "Neighbor list cutoff (A) for grid calculation"
  Bool calc_potentials = True
  ## form calc_potentials.name = "Calculate long-range potentials on the grid"
}

Type AttractIteration {
  ## form rcut.add_header("The nonbonded pairlist distance cutoff (rcut) (in A**2) during this iteration")
  *Float rcut = 1500
  ## form vmax.add_header("The maximum number of energy minimization steps (vmax)") 
  *Integer vmax = 100
  ## form traj.add_header("Trajectory mode: only minimize the first structure, and output the structure after every minimization step")
  Bool traj = False
  validate {
   assert rcut is None or rcut > 0
   assert vmax is None or vmax > 0
  }  
  
  Bool mc = False
  *Float mctemp = 3.5
  *Float mcscalerot = 0.05
  *Float mcscalecenter = 0.1
  *Float mcscalemode = 0.1
  *Float mcensprob = 0.1
  form {
    mc.group = "Monte Carlo"
    mc.name = "Enable Monte Carlo mode"
    mctemp.group = "Monte Carlo"
    mctemp.name = "Temperature (in kT)"
    mcscalerot.group = "Monte Carlo"
    mcscalerot.name = "Rotation step size (in radians)"
    mcscalecenter.group = "Monte Carlo"
    mcscalecenter.name = "Translation step size (in angstroms)"
    mcscalemode.group = "Monte Carlo"
    mcscalemode.name = "Mode deformation step size (in angstroms)"
    mcensprob.group = "Monte Carlo"
    mcensprob.name = "Probability to switch between ensemble conformers"
  }
  validate {
    assert mctemp is None or mctemp > 0
    assert mcensprob is None or (mcensprob >= 0 and mcensprob <= 1)
  }  
}

Type AttractModel {
  *String runname
  form {
    runname.add_header("Please supply a name for your docking run (one word)")
    runname.name = "Name"
  }  
  validate {
    if runname is not None:
      runname = runname.strip()
      self.runname = runname
      if not runname.replace("_","").replace("-","").isalnum():
        raise ValueError("The name of your run may contain only letters, digits, _ and -")  
  }
  
  AttractPartnerInterfaceArray partners
  form {
    partners.length = 10
    partners.name = "Docking partners"
    partners.form = "soft"
    for n in range(10):
      partners[n].name = "Docking partner %d" % (n+1)
      partners[n].group = "Docking partner %d" % (n+1)
  }
  AttractGridArray grids = []
  form {
    grids.length = 5
    grids.group = "Grids"
    grids.name = "Grid"
    grids.form = "soft"
    grids.count_from_one = True
  }  
  
  #***Iteration parameters***  
  *Integer nr_iterations
  AttractIterationArray iterations = []
  form {      
    nr_iterations.default = 1
    nr_iterations.group = "Iteration parameters"
    nr_iterations.name = "Number of iterations"
    iterations.group = "Iteration parameters"
    iterations.length = 5
    iterations.form = "soft"
    iterations[0].name = "First iteration"
    iterations[1].name = "Second iteration"
    iterations[2].name = "Third iteration"
    iterations[3].name = "Fourth iteration"
    iterations[4].name = "Fifth iteration"
  }  
  validate {
    if nr_iterations is not None:
      assert nr_iterations > 0
      assert nr_iterations >= len(iterations)
  }
  *Bool zoom = False  
  *Integer zoom_select = 1000
  *Integer zoom_clone = 20
  *Float zoom_ori = 0.25
  *Float zoom_trans = 5
  *AttractIteration zoom_it_initial
  *AttractIteration zoom_it_subsequent  
  form {
    zoom.group = "Iteration parameters"
    zoom.add_header("Do you want to use a zoom-in protocol?")
    zoom.add_header("Note that a zoom-in protocol ignores the parameters for the individual iterations")
    zoom.name = "Use zoom-in protocol"      
    
    zoom_select.group = "Iteration parameters"
    zoom_select.name = "Zoom-in protocol: number of structures to select after each iteration"
    zoom_clone.group = "Iteration parameters"
    zoom_clone.name = "Zoom-in protocol: cloning factor"
    zoom_ori.group = "Iteration parameters"
    zoom_ori.name = "Zoom-in protocol: rotational displacement (radians)"
    zoom_trans.group = "Iteration parameters"
    zoom_trans.name = "Zoom-in protocol: translation displacement (angstroms)"
    zoom_it_initial.group = "Iteration parameters"
    zoom_it_initial.name = "Zoom-in protocol: First iteration"
    zoom_it_subsequent.group = "Iteration parameters"
    zoom_it_subsequent.name = "Zoom-in protocol: subsequent iterations"
    

  }
  validate {
    if zoom: assert zoom_select is not None
    if zoom: assert zoom_clone is not None
    assert zoom_clone is None or zoom_clone > 1
    if zoom: assert zoom_ori is not None
    if zoom: assert zoom_trans is not None
    if zoom: assert zoom_it_initial is not None
    if zoom_it_initial is not None: assert zoom_it_initial.traj == False
    if zoom and nr_iterations > 1: assert zoom_it_subsequent is not None
    if zoom_it_subsequent is not None: assert zoom_it_subsequent.traj == False
  }
  #***Sampling parameters***
  Bool fix_receptor = False
  ## form fix_receptor.name = "Fix the receptor during docking"    
  Enum search("syst","random", "custom")
  ## form search.name = "Docking search"
  ## form search.optiontitles = "Systematic","Random", "Custom"
  validate {
    for p in partners:
      if p.ensemblize == "custom": assert search == "custom"
  }  
  Integer structures = 10000
  ## form structures.name = "Number of structures for random search"
  *ResourceData_ATTRACT_Structures start_structures_file
  ## form start_structures_file.type = "file"
  *ResourceData_ATTRACT_Rotations rotations_file
  ## form rotations_file.type = "file"
  *ResourceData_ATTRACT_Translations translations_file
  ## form translations_file.type = "file"
  form {
    start_structures_file.add_header("Custom search files")
    start_structures_file.add_header("For a custom search, supply a starting structures file, OR: rotations and/or translations files")
    start_structures_file.name = "Starting structures file for custom search"
    rotations_file.name = "Rotations file for custom search"
    translations_file.name = "Translations file for custom search"
  }
  validate {
    if search != "custom":
      assert rotations_file is None
      assert translations_file is None
      assert start_structures_file is None
      if search == "syst": assert len(partners) == 2
    elif start_structures_file is not None:
      assert rotations_file is None
      assert translations_file is None
    else:
      assert rotations_file is not None or translations_file is not None      
      assert len(partners) == 2
  }   
  form {
    fix_receptor.group = "Sampling parameters"
    search.group = "Sampling parameters"
    structures.group = "Sampling parameters"
    start_structures_file.group = "Sampling parameters"
    rotations_file.group = "Sampling parameters"
    translations_file.group = "Sampling parameters"
  }
  #*** 

  #***Energy and interaction parameters***
  Integer gravity
  form {
    gravity.name = "Gravity"
    gravity.type = "option"
    gravity.options = (0,1,2,3,4,5)
    gravity.optiontitles = ("No gravity", "To global origin", "To receptor", "Between all ligands", "Cryo-EM pre-assembly stage gravity", "Cryo-EM assembly stage gravity")
  }  
  *Float rstk = 0.2
  form {
    rstk.name = "Restraining force constant"
    rstk.digits = 4
  }
  
  Enum forcefield("ATTRACT", "OPLSX") = "ATTRACT"
  ## form forcefield.add_header("Which forcefield is to be used?")
  ## form forcefield.name = "Forcefield"
  Bool ghost = False
  ## form ghost.add_header("In ghost mode, the forcefield is turned off")
  ## form ghost.name = "Enable ghost mode"

  *Float epsilon = 15
  ## form #epsilon.group = "Sampling parameters"
  ## form epsilon.add_header("Epsilon constant for the electrostatic energy term")
  ## form epsilon.name = "Epsilon"
  
  Enum dielec("cdie", "rdie") = "rdie"
  ## form dielec.name = "Use constant (cdie) or distance-dependent (rdie) dielectric"
  form {
    _g = "Energy and interaction parameters"
    gravity.group = _g
    rstk.group = _g
    forcefield.group = _g
    ghost.group = _g
    epsilon.group = _g
    dielec.group = _g
  }
  #***
  
  *ResourceData_ATTRACT_CryoEM cryoem_data
  form {
    cryoem_data.group = "Cryo-EM data"
    cryoem_data.type = "file"
    cryoem_data.name = "Cryo-EM density map (SITUS format)"
  }  
  *Float cryoem_resolution
  form {
    cryoem_resolution.group = "Cryo-EM data"
    cryoem_resolution.name = "Cryo-EM density map resolution (in angstroms)"
  }  
  validate {
    if cryoem_data is not None: assert cryoem_resolution is not None
    if cryoem_data is None: assert cryoem_resolution is None
  }

  Enum cryoem_scoring_mode("no","attract","gvm","cc") = "no"
  form {
    cryoem_scoring_mode.group = "Cryo-EM data"
    cryoem_scoring_mode.name = "Cryo-EM scoring criterion"
    cryoem_scoring_mode.optiontitles = ("No separate scoring step with a higher-resolution map", "ATTRACT energy", "GVM score", "cross-correlation")
  }
  *ResourceData_ATTRACT_CryoEM cryoem_scoring_data
  form {
    cryoem_scoring_data.group = "Cryo-EM data"
    cryoem_scoring_data.type = "file"
    cryoem_scoring_data.name = "Cryo-EM density map used in scoring (SITUS format)"
  }  
  *Float cryoem_scoring_resolution
  form {
    cryoem_scoring_resolution.group = "Cryo-EM data"
    cryoem_scoring_resolution.name = "Cryo-EM scoring density map resolution (in angstroms)"
  }  
  validate {
    if cryoem_scoring_mode == "no": assert cryoem_scoring_data is None
    if cryoem_scoring_mode != "no": assert cryoem_scoring_data is not None
    if cryoem_scoring_data is not None: assert cryoem_scoring_resolution is not None
    if cryoem_scoring_data is None: assert cryoem_scoring_resolution is None
    if cryoem_scoring_data is not None: assert cryoem_data is not None
    if cryoem_scoring_resolution is not None: assert cryoem_scoring_resolution <= cryoem_resolution    
  }
  
  AttractSymmetryArray symmetries = []
  form {
    symmetries.length = 5
    symmetries.name = "Symmetry"
    symmetries.count_from_one = True
    symmetries.form = "soft"
    symmetries[None].symmetry.name = "Symmetry type"
    symmetries[None].partners.name = "Symmetry partners"
    symmetries[None].partners.length = 12
    for n in range(12):
      symmetries[None].partners[n].name = n+1
  }  
  
  #**Analysis***  
  Bool rescoring = True  
  *Float rcut_rescoring = 50.0    
  Bool sort = True
  Bool deredundant = True
  Bool deredundant_ignorens = True
  *Bool calc_lrmsd = False  
  *Bool calc_irmsd = False
  *Bool calc_fnat = False
  Bool collect = True
  Integer nr_collect = 50
  form {
    rescoring.group = "Analysis"
    rcut_rescoring.group = "Analysis"
    sort.group = "Analysis"
    deredundant.group = "Analysis"
    deredundant_ignorens.group = "Analysis"
    calc_lrmsd.group = "Analysis"
    calc_irmsd.group = "Analysis"
    calc_fnat.group = "Analysis"
    collect.group = "Analysis"
    nr_collect.group = "Analysis"
    
    rescoring.name = "Perform a rescoring step after docking"
    rcut_rescoring.add_header("The nonbonded pairlist distance cutoff (rcut) (in A**2) during rescoring")
    rcut_rescoring.name = "rcut (rescoring)"
    sort.name = "Sort the final structures according to ATTRACT energy"
    deredundant.name = "Remove redundant structures after docking"
    deredundant_ignorens.name = "Ignore ensemble conformers for redundancy"
    calc_lrmsd.name = "Calculate ligand RMSD after docking"
    calc_irmsd.name = "Calculate interface RMSD after docking"
    calc_fnat.name = "Calculate fraction of native contacts after docking"
    collect.name = "Collect the structures as PDBs after docking"
    nr_collect.name = "Number of structures to collect"
  }
  #***
    
  #***Computing and parallelization parameters***
  Integer np = 1
  ## form np.group = "Computing and parallelization parameters"
  ## form np.name = "Number of processor cores"
  Integer jobsize = 0
  ## form jobsize.group = "Computing and parallelization parameters"
  ## form jobsize.name = "Number of structures in a single job (leave blank to divide all structures equally over the cores)"
  
  *String header = ""
  ## form header.group = "Computing and parallelization parameters"
  ## form header.name = "Header for docking protocol script"
  ## form header.default = "#PBS -l nodes=1:ppn=12\n#PBS -l walltime=6:30:00\n#PBS -j oe\ncd $PBS_O_WORKDIR\n\nATTRACTDIR=/home/sjoerd/data/work/attract/bin\nATTRACTTOOLS=/home/sjoerd/data/work/attract/tools\n"
  ## form header.type = "textarea"
  ## form header.cols = 80
  ## form header.rows = 50

  *String footer = ""
  ## form footer.group = "Computing and parallelization parameters"
  ## form footer.name = "Footer for docking protocol script"
  ## form footer.type = "textarea"
  ## form footer.cols = 80
  ## form footer.rows = 5
  
  #***
  
  validate {
    #TODO: grid alphabet
    gridnames = set([g.gridname for g in grids])
    for partner in partners:
      if partner.gridname is not None:
        assert partner.gridname in gridnames, partner.gridname     
    #TODO: mixed-model docking (e.g. some partners coarse-grained, others all-atom)
    
    if calc_lrmsd: assert len(partners) == 2
    if calc_irmsd: assert len(partners) == 2
  }
  
  error {
    'if zoom is not None: assert zoom_it_initial is not None'
    =>
    ''

    'if zoom is not None: assert zoom_trans is not None'
    =>
    ''

    'if cryoem_scoring_mode != None: assert cryoem_scoring_mode in ("no","attract","gvm","cc")'
    =>
    ''

    'assert nr_iterations > 0'
    =>
    ''

    'if dielec != None: assert dielec in ("cdie", "rdie")'
    =>
    ''

    'if zoom_it_initial is not None: assert zoom_it_initial.traj == False'
    =>
    ''

    'assert rotations_file is None'
    =>
    ''

    'if zoom is not None: assert zoom_select is not None'
    =>
    ''

    'if cryoem_data is None: assert cryoem_resolution is None'
    =>
    ''

    'if cryoem_scoring_mode != "no": assert cryoem_scoring_data is not None'
    =>
    ''

    'if forcefield != None: assert forcefield in ("ATTRACT", "OPLSX")'
    =>
    ''

    'if cryoem_scoring_resolution is not None: assert cryoem_scoring_resolution <= cryoem_resolution'
    =>
    ''

    'if cryoem_scoring_data is not None: assert cryoem_data is not None'
    =>
    ''

    'assert start_structures_file is None'
    =>
    ''

    'if calc_irmsd: assert len(partners) == 2'
    =>
    ''

    'assert nr_iterations >= len(iterations)'
    =>
    ''

    'assert partner.gridname in gridnames, partner.gridname'
    =>
    ''

    'if cryoem_scoring_data is not None: assert cryoem_scoring_resolution is not None'
    =>
    ''

    'assert zoom_clone is None or zoom_clone > 1'
    =>
    ''

    'assert len(partners) == 2'
    =>
    'You must define two docking partners, not {len(partners)}'

    'if calc_lrmsd: assert len(partners) == 2'
    =>
    ''

    'if zoom is not None: assert zoom_clone is not None'
    =>
    ''

    'if zoom is not None: assert zoom_ori is not None'
    =>
    ''

    'if zoom_it_subsequent is not None: assert zoom_it_subsequent.traj == False'
    =>
    ''

    'if p.ensemblize == "custom": assert search == "custom"'
    =>
    ''

    'if cryoem_data is not None: assert cryoem_resolution is not None'
    =>
    ''

    'if search == "syst": assert len(partners) == 2'
    =>
    ''

    'if search != None: assert search in ("syst","random", "custom")'
    =>
    ''

    'if zoom is not None and nr_iterations > 1: assert zoom_it_subsequent is not None'
    =>
    ''

    'assert rotations_file is not None or translations_file is not None'
    =>
    ''

    'if cryoem_scoring_mode == "no": assert cryoem_scoring_data is None'
    =>
    ''

    'assert translations_file is None'
    =>
    ''

    'raise ValueError("The name of your run may contain only letters, digits, _ and -")'
    =>
    ''

    'if cryoem_scoring_data is None: assert cryoem_scoring_resolution is None'
    =>
    ''
    
  }
  
}

Method generate(AttractModel) generate
