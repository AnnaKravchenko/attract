Type Data_DSSP:Data {}

Type GenSymmetry:Degenerate {
  """
  Generative C- or D-symmetry can be imposed
  The symmetry axis is assumed to be the Z axis
  In case of D symmetry, a secondary symmetry axis must be provided
  In all cases, a symmetry axis is assumed to go through the global origin
  """
  Enum symmetry("No symmetry", "C2","C3","C4","C5","C6","C7","D2")
  *Vector secondary_axis
  form {
    symmetry.name = "Symmetry type"
    secondary_axis.name = "Secondary symmetry axis (for D symmetry)"
  }
  validate {
    if symmetry[0] == "C": assert secondary_axis is None
    if symmetry[0] == "D": assert secondary_axis is not None
  }
  error {
    'if symmetry[0] == "C": assert secondary_axis is None'
    =>
    ''

    'if symmetry is not None: assert symmetry in ("No symmetry", "C2","C3","C4","C5","C6","C7","D2")'
    =>
    ''

    'if symmetry[0] == "D": assert secondary_axis is not None'
    =>
    ''
  }
}

Type CryoSequenceMapping {
  *String chain
  Integer index
  RangeArray subsequences = []
  *Integer shift
  form {
    t = "You may select a chain of the mapped PDB, or leave it blank"
    chain.add_header(t)
    chain.tooltip = t
    chain.length = 2
    index.name = "Index of the assembly sequence to map to"
    t = "The sequence stretches to which the PDB is aligned; leave blank for automatic alignment"    
    subsequences.tooltip = t
    subsequences.length = 5
    subsequences.count_from_one = True
    subsequences[0].add_header(t)
    subsequences.form = "soft"
    t = "It is possible to indicate symmetry shifts in the mapped PDB, causing linker restraints to be defined to bodies in the next/previous symmetry copy, instead of to bodies in the reference copy"
    shift.add_header(t)
    shift.name = "Symmetry shift"
    shift.tooltip = t
  }
}

Type CryoPartner:Degenerate {
  """
  High-level definition of a component that is to be fitted
  A CryoPartner has a single PDB, and/or a sequence mapping, and/or a DSSP assignment  
  The PDB consists of one or more chains  
  A CryoPartner has different options for how it is to be converted into CryoBodies  
  - mode "single": 
    The PDB consists of a single chain. If a sequence range has been defined, the PDB must align to that range, else it will be auto-aligned
    The CryoPartner will be mapped onto a single CryoBody. 
  - mode "multi"
    The PDB consists of multiple chains. If a sequence range has been defined, all chains together must align to that range, else it will be auto-aligned
    -relplace "fixed": The relative positions of the chains is fixed. The partner maps to a single CryoBody
    -relplace "guess": (guess) The relative positions of the chains are an initial estimate, they can re-adjust during refinement. The partner maps to one CryoBody per chain
    -relplace "estimate": (good estimate) Same as above, but a restraining force will enforce resemblance to the initial positioning
    -relplace "free": The CryoPartner will be split into independent CryoBodies, one per chain
  - mode "SSE":  
    The PDB consists of a single chain. If a sequence range has been defined, the PDB must align to that range, else it will be auto-aligned
    The PDB will be auto-fragmented into secondary structure element bodies, based on the DSSP assignment if provided, or else automatically
  - mode "ab_initio"  
    No PDB has been provided. Sequence and DSSP alignment must be provided. The sequence will be fragmented into secondary structure element bodies, based on the DSSP assignment.
    Idealized SSE fragment PDBs will be built ab initio.    
  """
  Enum mode("single", "multi", "SSE", "ab_initio")
  *ResourceData_PDB pdb
  *ResourceData_DSSP dssp
  CryoSequenceMappingArray sequencemappings = []
  Enum absplace("free","guess","estpos","estimate","fixed") = "free"
  Enum relplace("free","guess","estpos","estimate","fixed") = "free" 
  Enum missing_loops("forbidden","neglect","ignore","ab_initio") = "neglect" 
  Float floppiness = 0
  form {
    pdb.type = "file"
    dssp.type = "file"
    mode.name = "What kind of protein body?"
    mode.optiontitles = (
      "Single body",
      "Multiple bodies",
      "Structure will be split into secondary structure bodies",
      "Structure will be built from idealized secondary structure"
    )  
    pdb.name = "PDB structure"
    dssp.name = "DSSP secondary structure assignment"
    sequencemappings.length = 3
    sequencemappings.count_from_one = True
    sequencemappings.form = "soft"
    sequencemappings.name = "Mapping to assembly sequences"
    sequencemappings.tooltip = "Mapping of the reference structure to the assembly sequences"    
    ot = ("Free", "Initial guess", "Estimate, restrained position", "Estimate, restrained position and orientation", "Fixed position and orientation")
    absplace.name = "Absolute placement of the entire PDB"
    absplace.optiontitles = ot
    relplace.name = "Relative placement of the bodies within the PDB"
    relplace.optiontitles = ot    
    t = "How should missing loops (between the PDB sequence's start and end) be treated?"
    missing_loops.add_header(t)  
    missing_loops.name = "Missing loops"
    missing_loops.optiontitles = (
     "Forbidden: PDB sequence corresponds exactly to the sequence mapping",
     "Neglect: PDB contains only small missing loops, which are not modeled",
     "Ignore: missing loops are not modeled",
     "Build: missing loops are built from individual amino acids" 
    )
    missing_loops.tooltip = t
    t = "Uncertainty about endpoint coordinates (floppiness), in angstroms"
    floppiness.add_header(t)
    floppiness.name = "Floppiness"
    floppiness.tooltip = t
  }
  validate {
    if mode != "ab_initio": assert pdb is not None 
    if mode != "multi": assert relplace == "free"
    if dssp is not None: assert mode in "SSE", "ab_initio"
    if mode == "ab_initio": assert dssp is not None
    if mode == "ab_initio": assert len(sequencemappings)    
  }  
  error {
    'if relplace is not None: assert relplace in ("free","guess","estpos","estimate","fixed")'
    =>
    ''

    'if missing_loops is not None: assert missing_loops in ("forbidden","neglect","ignore","ab_initio")'
    =>
    ''

    'if absplace is not None: assert absplace in ("free","guess","estpos","estimate","fixed")'
    =>
    ''

    'if mode == "ab_initio": assert len(sequencemappings)'
    =>
    ''

    'if mode == "ab_initio": assert dssp is not None'
    =>
    ''

    'if mode is not None: assert mode in ("single", "multi", "SSE", "ab_initio")'
    =>
    ''

    'if dssp is not None: assert mode in "SSE", "ab_initio"'
    =>
    ''

    'if mode != "multi": assert relplace == "free"'
    =>
    ''

    'if mode != "ab_initio": assert pdb is not None'
    =>
    ''
  }
}

Type CryoBody {
  """
  Low-level definition of a component that is to be fitted
  """  
  Enum mode("structure", "missing region", "ab_initio")
  *ResourceData_PDB pdb
  CryoSequenceMappingArray sequencemappings = []
  Enum absplace("free","guess","estpos","estimate","fixed")
  Enum missing_loops("forbidden","neglect","ignore","ab_initio") = "neglect" 
  Float floppiness  
  form {
    pdb.type = "file"
    mode.name = "What kind of protein body?"
    mode.optiontitles = (
      "Fitted structure",
      "Missing sequence region",
      "Built from amino acids"
    )
    pdb.name = "PDB structure"
    sequencemappings.length = 3
    sequencemappings.count_from_one = True
    sequencemappings.form = "soft"
    sequencemappings.name = "Mapping to assembly sequences"
    sequencemappings.tooltip = "Mapping of the reference structure to the assembly sequences"    
    ot = ("Free", "Initial guess", "Estimate, restrained position", "Estimate, restrained position and orientation", "Fixed position and orientation")
    absplace.name = "Absolute placement of the entire PDB"
    absplace.optiontitles = ot
    t = "How should missing loops (between the PDB sequence's start and end) be treated?"
    missing_loops.add_header(t)   
    missing_loops.name = "Missing loops"
    missing_loops.optiontitles = (
     "Forbidden: PDB sequence corresponds exactly to the sequence mapping",
     "Neglect: PDB contains only small missing loops, which are not modeled",
     "Ignore: missing loops are not modeled",
     "Build: missing loops are built from individual amino acids" 
    )
    missing_loops.tooltip = t
    t = "Uncertainty about endpoint coordinates (floppiness), in angstroms"
    floppiness.add_header(t)
    floppiness.name = "Floppiness"
    floppiness.tooltip = t
  }
  validate {
    assert len(sequencemappings)
    if mode == "structure": assert pdb is not None
    if mode != "structure": assert pdb is None
  }  
  error {
    'if missing_loops is not None: assert missing_loops in ("forbidden","neglect","ignore","ab_initio")'
    =>
    ''

    'if absplace is not None: assert absplace in ("free","guess","estpos","estimate","fixed")'
    =>
    ''

    'if mode is not None: assert mode in ("structure", "missing region", "ab_initio")'
    =>
    ''

    'assert len(sequencemappings)'
    =>
    ''

    'if mode != "structure": assert pdb is None'
    =>
    ''

    'if mode == "structure": assert pdb is not None'
    =>
    ''
  }
}

#TODO: floppiness: (root of sum of squares of 2 endpoint floppinesses is added to max linker distance)